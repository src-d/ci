# Package configuration
PROJECT ?=
COMMANDS ?=
DEPENDENCIES ?=

# Default shell
SHELL := /bin/bash

# Dockerfiles to be built, list of file:name pairs, example `Dockerfile:my-image`
DOCKERFILES ?= Dockerfile:$(PROJECT)
# Docker registry where the docker image should be pushed to.
DOCKER_REGISTRY ?= docker.io
# Docker organization to be used at the docker image name.
DOCKER_ORG ?= src-d
# Username used to login on the docker registry.
DOCKER_USERNAME ?=
# Password used to login on the docker registry.
DOCKER_PASSWORD ?=
# When `make docker-push`, setting DOCKER_PUSH_LATEST to any non-empty value
# will cause make docker-push to also push the latest tag.
DOCKER_PUSH_LATEST ?=
# Docker OS/Arch used to match the right binaries.
DOCKER_OS ?= $(shell docker version -f "{{.Server.Os}}")
DOCKER_ARCH ?= $(shell docker version -f "{{.Server.Arch}}")

# Checking mandatory variables
ifndef PROJECT
$(error ERROR! The PROJECT variable cannot be empty)
endif

# Environment
WORKDIR := $(PWD)
BUILD_PATH := $(WORKDIR)/build
BIN_PATH := $(BUILD_PATH)/bin
BRANCH ?= $(shell git rev-parse --abbrev-ref HEAD)

# Build information
BUILD ?= $(shell date +"%m-%d-%Y_%H_%M_%S")
COMMIT ?= $(shell git rev-parse --short HEAD)
GIT_DIRTY = $(shell test -n "`git status --porcelain`" && echo "-dirty" || true)
DEV_PREFIX := dev
VERSION ?= $(DEV_PREFIX)-$(COMMIT)$(GIT_DIRTY)

# Travis CI
ifeq ($(TRAVIS), true)
	WORKDIR := $(TRAVIS_BUILD_DIR)
	BUILD_PATH := $(WORKDIR)/build
	VERSION := $(TRAVIS_BRANCH)
endif

# Drone CI
ifeq ($(DRONE), true)
	ifeq ($(DRONE_BUILD_EVENT), tag)
		VERSION := $(DRONE_TAG)
	else
		VERSION := $(DRONE_BRANCH)
	endif
endif

# Packages content
PKG_OS ?= darwin linux
PKG_ARCH = amd64

# LD_FLAGS to be use at `go build` calls.
LD_FLAGS ?= -X main.version=$(VERSION) -X main.build=$(BUILD) -X main.commit=$(COMMIT)
# Tags to be used as `-tags` argument at `go build` and `go install`
GO_TAGS ?=
# Arguments to be used in `go` commands.
GO_GET_ARGS ?= -v -t
GO_TEST_ARGS ?= -v
GO_BUILD_ARGS ?= -ldflags "$(LD_FLAGS)"
# Environment variable to use at `go build` calls.
GO_BUILD_ENV ?=

# Go parameters
ifneq ($(GO_TAGS), )
	GO_GET_ARGS += -tags "$(GO_TAGS)"
	GO_TEST_ARGS += -tags "$(GO_TAGS)"
	GO_BUILD_ARGS += -tags "$(GO_TAGS)"
endif

GOCMD = go
GOGET = $(GOCMD) get $(GO_GET_ARGS)
GOBUILD = $(GOCMD) build $(GO_BUILD_ARGS)
GOTEST = $(GOCMD) test $(GO_TEST_ARGS)
GOTEST_RACE = $(GOTEST) -race
GOCLEAN = $(GOCMD) clean
CGO_ENABLED ?= 0

# Coverage
COVERAGE_REPORT = coverage.txt
COVERAGE_PROFILE = profile.out
COVERAGE_MODE = atomic

PACKAGES = $(shell go list ./... | grep -v '/vendor/')

# Rules
dependencies: $(DEPENDENCIES)
	$(GOGET) -t ./...

$(DEPENDENCIES):
	$(GOGET) $@/...

test:
	$(GOTEST) $(PACKAGES)

test-race:
	$(GOTEST_RACE) $(PACKAGES)

test-coverage:
	@cd $(WORKDIR); \
	echo "" > $(COVERAGE_REPORT); \
	for dir in $(PACKAGES); do \
		$(GOTEST) $$dir -coverprofile=$(COVERAGE_PROFILE) -covermode=$(COVERAGE_MODE); \
		if [ $$? != 0 ]; then \
			exit 2; \
		fi; \
		if [ -f $(COVERAGE_PROFILE) ]; then \
			cat $(COVERAGE_PROFILE) >> $(COVERAGE_REPORT); \
			rm $(COVERAGE_PROFILE); \
		fi; \
	done || exit 1; \

codecov:
	@if [ ! -f $(COVERAGE_REPORT) ]; then \
		echo "Unable to find '$(COVERAGE_REPORT)', execute 'make test-coverage' first."; \
		exit 1; \
	fi; \
	bash <(curl -s https://codecov.io/bash);

build: $(COMMANDS)
$(COMMANDS):
	@cd $(WORKDIR)/$@; \
	for os in $(PKG_OS); do \
		for arch in $(PKG_ARCH); do \
			mkdir -p $(BUILD_PATH)/$(PROJECT)_$${os}_$${arch}; \
			$(GO_BUILD_ENV) CGO_ENABLED=$(CGO_ENABLED) GOOS=$${os} GOARCH=$${arch} \
				$(GOBUILD) -o "$(BUILD_PATH)/$(PROJECT)_$${os}_$${arch}/`basename $@`" .; \
			if [ "$(DOCKER_OS)" == "$${os}" ] && [ "$(DOCKER_ARCH)" == "$${arch}" ]; then \
				echo "Linking matching OS/Arch binaries to "build/bin" folder"; \
				mkdir -p $(BIN_PATH); \
				cp -rf $(BUILD_PATH)/$(PROJECT)_$${os}_$${arch}/`basename $@` $(BIN_PATH); \
			fi; \
		done; \
	done

docker-login: docker-validate
	@docker login -u "$(DOCKER_USERNAME)" -p "$(DOCKER_PASSWORD)" $(DOCKER_REGISTRY); \

docker-validate:
	@if [ -z "$(DOCKER_USERNAME)" ]; then \
		echo "DOCKER_USERNAME variable cannot be empty."; \
		exit 1; \
	fi; \
	if [ -z "$(DOCKER_PASSWORD)" ]; then \
		echo "DOCKER_PASSWORD variable cannot be empty."; \
		exit 1; \
	fi

docker-build: $(COMMANDS)
	@if [ -z "$(DOCKER_ORG)" ]; then \
		echo "DOCKER_ORG variable cannot be empty."; \
		exit 1; \
	fi; \
	for d in $(DOCKERFILES); do \
		dockerfile=`echo $${d} | cut -d":" -f 1`; \
		repository=`echo $${d} | cut -d":" -f 2`; \
		docker build -t $(DOCKER_REGISTRY)/$(DOCKER_ORG)/$${repository}:$(VERSION) -f $(WORKDIR)/$$dockerfile .; \
	done;

docker-push: docker-login docker-build
	@if [ "$(BRANCH)" == "master" ]; then \
		echo "docker-push is disabled on master branch" \
		exit 1; \
	fi; \
	for d in $(DOCKERFILES); do \
		dockerfile=`echo $${d} | cut -d":" -f 1`; \
		repository=`echo $${d} | cut -d":" -f 2`; \
		docker push $(DOCKER_REGISTRY)/$(DOCKER_ORG)/$${repository}:$(VERSION); \
		if [ -n "$(DOCKER_PUSH_LATEST)" ]; then \
		 	docker tag $(DOCKER_REGISTRY)/$(DOCKER_ORG)/$${repository}:$(VERSION) \
				$(DOCKER_REGISTRY)/$(DOCKER_ORG)/$${repository}:latest; \
			docker push $(DOCKER_REGISTRY)/$(DOCKER_ORG)/$${repository}:latest; \
		fi; \
	done;

packages: build
	@cd $(BUILD_PATH); \
	for os in $(PKG_OS); do \
		for arch in $(PKG_ARCH); do \
			TAR_VERSION=`echo $(VERSION) | tr "/" "-"`; \
			tar -cvzf $(PROJECT)_$(TAR_VERSION)_$${os}_$${arch}.tar.gz $(PROJECT)_$${os}_$${arch}/; \
		done; \
	done

clean:
	rm -rf $(BUILD_PATH) $(BIN_PATH) $(VENDOR_PATH)
	$(GOCLEAN) .

no-changes-in-commit:
	git status --untracked-files=no --porcelain | grep -qe '..*'; \
	if  [ $$? -eq 0 ] ; then \
		git diff|cat; \
		echo >&2 "generated assets are out of sync"; \
		exit 2; \
	fi

.PHONY: dependencies $(DEPENDENCIES) \
		build $(COMMANDS) \
		test test-race test-coverage \
		docker-login docker-validate docker-build docker-push \
		packages \
		clean \
		no-changes-in-commit
